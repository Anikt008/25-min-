import React, { useState, useEffect, useCallback, useRef } from 'react';
import { TimerMode, TimerState } from './types';
import { DEFAULT_CONFIG } from './constants';
import TimerDisplay from './components/TimerDisplay';
import Controls from './components/Controls';
import CycleProgress from './components/CycleProgress';
import MotivationCard from './components/MotivationCard';
import confetti from 'canvas-confetti';
import { BrainCircuit } from 'lucide-react';

const App: React.FC = () => {
  const [state, setState] = useState<TimerState>({
    timeLeft: DEFAULT_CONFIG.workDuration,
    isActive: false,
    mode: TimerMode.WORK,
    currentCycle: 1,
    totalCycles: DEFAULT_CONFIG.cycles,
  });

  const timerRef = useRef<number | null>(null);

  // Audio for notifications
  // Using a simple beep generated by AudioContext would be better for no-asset dependency, 
  // but let's use a standard reliable sound URL or simple logic.
  // For strict "no made up libraries", we'll just not rely on an external sound file that might break.
  // We will assume a visual queue is primary, but I'll add a simple oscillator beep function.
  const playSound = useCallback((type: 'tick' | 'finish') => {
    try {
        const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
        if (!AudioContext) return;
        
        const ctx = new AudioContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.connect(gain);
        gain.connect(ctx.destination);

        if (type === 'finish') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(523.25, ctx.currentTime); // C5
            osc.frequency.exponentialRampToValueAtTime(1046.5, ctx.currentTime + 0.1); // C6
            gain.gain.setValueAtTime(0.5, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
            osc.start();
            osc.stop(ctx.currentTime + 0.5);
        } else {
            // Very quiet tick
            // osc.type = 'triangle';
            // osc.frequency.setValueAtTime(800, ctx.currentTime);
            // gain.gain.setValueAtTime(0.05, ctx.currentTime);
            // gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);
            // osc.start();
            // osc.stop(ctx.currentTime + 0.05);
        }
    } catch (e) {
        console.error("Audio play failed", e);
    }
  }, []);


  const switchMode = useCallback(() => {
    setState(prev => {
      const isWork = prev.mode === TimerMode.WORK;
      const nextMode = isWork ? TimerMode.BREAK : TimerMode.WORK;
      
      // If we just finished a BREAK, we complete a full cycle and move to next
      // If we just finished WORK, we are still in same cycle number, just break phase
      
      // Logic:
      // Cycle 1: Work (25) -> Break (5)
      // Cycle 2: Work (25) -> Break (5)
      // ...
      // Cycle 8: Work (25) -> Break (5) -> FINISH
      
      let nextCycle = prev.currentCycle;
      
      // If we are currently in BREAK mode and it finishes, we move to next cycle Work
      if (!isWork) {
         nextCycle = prev.currentCycle + 1;
      }

      // Check if we finished all cycles
      if (nextCycle > prev.totalCycles) {
        playSound('finish');
        confetti({
          particleCount: 150,
          spread: 70,
          origin: { y: 0.6 },
          colors: ['#f43f5e', '#10b981', '#6366f1']
        });
        return {
          ...prev,
          mode: TimerMode.FINISHED,
          isActive: false,
          timeLeft: 0,
          currentCycle: prev.totalCycles
        };
      }

      playSound('finish'); // End of a phase sound

      return {
        ...prev,
        mode: nextMode,
        timeLeft: nextMode === TimerMode.WORK ? DEFAULT_CONFIG.workDuration : DEFAULT_CONFIG.breakDuration,
        currentCycle: nextCycle,
        isActive: false // Auto-pause between phases? Or auto-continue? Usually auto-pause is safer for user awareness.
      };
    });
  }, [playSound]);

  const tick = useCallback(() => {
    setState(prev => {
      if (prev.timeLeft <= 1) {
        switchMode();
        return prev; // switchMode handles the state update
      }
      return { ...prev, timeLeft: prev.timeLeft - 1 };
    });
  }, [switchMode]);

  useEffect(() => {
    if (state.isActive && state.mode !== TimerMode.FINISHED) {
      timerRef.current = window.setInterval(tick, 1000);
    } else {
      if (timerRef.current) clearInterval(timerRef.current);
    }

    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, [state.isActive, state.mode, tick]);

  const toggleTimer = () => {
    setState(prev => ({ ...prev, isActive: !prev.isActive }));
  };

  const resetTimer = () => {
    setState(prev => ({
      ...prev,
      isActive: false,
      timeLeft: prev.mode === TimerMode.WORK ? DEFAULT_CONFIG.workDuration : DEFAULT_CONFIG.breakDuration
    }));
  };

  const skipPhase = () => {
    switchMode();
  };

  // Calculate total duration for the circle progress based on current mode
  const getCurrentTotalDuration = () => {
    if (state.mode === TimerMode.WORK) return DEFAULT_CONFIG.workDuration;
    if (state.mode === TimerMode.BREAK) return DEFAULT_CONFIG.breakDuration;
    return 1;
  };

  return (
    <div className="min-h-screen bg-slate-900 text-slate-100 flex flex-col items-center justify-center p-4">
      
      {/* Header */}
      <header className="absolute top-0 w-full p-6 flex items-center justify-between max-w-4xl">
        <div className="flex items-center gap-2">
            <div className="bg-gradient-to-br from-rose-500 to-indigo-600 p-2 rounded-lg">
                <BrainCircuit size={24} className="text-white" />
            </div>
            <h1 className="text-xl font-bold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-white to-slate-400">
                Focus Flow
            </h1>
        </div>
        <div className="text-sm text-slate-500 font-medium">
            25 â€” 5 Method
        </div>
      </header>

      {/* Main Content */}
      <main className="w-full max-w-xl">
        {state.mode === TimerMode.FINISHED ? (
           <div className="text-center py-20 animate-fade-in">
              <h2 className="text-5xl font-bold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-rose-400">
                You Did It!
              </h2>
              <p className="text-slate-400 text-lg mb-8">
                8 Cycles complete. Enjoy your well-earned rest.
              </p>
              <button 
                onClick={() => window.location.reload()}
                className="px-8 py-3 bg-indigo-600 hover:bg-indigo-700 rounded-full font-semibold transition-colors"
              >
                Start New Session
              </button>
           </div>
        ) : (
          <>
            <div className="mb-8">
               <TimerDisplay 
                 timeLeft={state.timeLeft} 
                 totalTime={getCurrentTotalDuration()} 
                 mode={state.mode} 
               />
            </div>

            <CycleProgress 
              currentCycle={state.currentCycle} 
              totalCycles={state.totalCycles}
              completedCycles={0} // Computed inside component essentially
            />

            <Controls 
              isActive={state.isActive} 
              mode={state.mode} 
              onToggle={toggleTimer} 
              onReset={resetTimer} 
              onSkip={skipPhase}
            />

            <MotivationCard mode={state.mode} isActive={state.isActive} />
          </>
        )}
      </main>

      {/* Footer */}
      <footer className="absolute bottom-4 text-slate-600 text-xs text-center w-full">
         <p>Stay consistent. Trust the process.</p>
      </footer>

    </div>
  );
};

export default App;